%! Author = Nectarios Chroniaris
%! Date = 2022-02-28

% Preamble
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{makecell}
\usepackage{xcolor}
\usepackage{amsmath}

\newcommand{\ts}{\textsuperscript}

\definecolor{verylightgray}{gray}{0.95}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% https://tex.stackexchange.com/a/119864
\lstset{
    frame=single,
    framesep=6pt,
    framerule=0pt,
    xleftmargin=8pt,
    mathescape=false,
    backgroundcolor=\color{verylightgray},
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}

%! suppress = LineBreak
%! suppress = TooLargeSection
\begin{document}

    \title{magpieCTF 2022 - Turn-Key Writeup}
    \author{Nectarios Chroniaris}

    \maketitle


    \section{Preamble}\label{sec:preamble}

    The intended solve, as documented on \href{https://github.com/infosec-ucalgary/magpieCTF2022-public/tree/main/challenges/networks/turn-key}{magpieCTF's public GitHub repo}, involves renting/using servers that are physically close to the vaults, in order to get each request to complete in the required 300 or so milliseconds.

    \bigskip

    However, by taking some clever shortcuts in the design of the protocol, we can reduce round-trip delays and otherwise unnecessary overhead, to squeeze the total delay under the required amount (yes, even for the server in Bangalore!).


    \section{Abridged Solution}\label{sec:abridged-solution}

    \begin{enumerate}
        \item Read the specification and understand what messages are required to fulfill the protocol.
        \begin{itemize}
            \item Use \verb`nmap` to scan the vault servers to see which port the protocol is hosted under.
            \item \verb`nmap -p 1-65535 -T4 -A -v vault1.momandpopsflags.ca`
            \item i.e.\ ``scan all ports from 1--65535, be aggressive (\verb`-T4`, \verb`-A`) and log verbosely''.
        \end{itemize}
        \item After finding the correct port (thankfully they are all the same!), try to connect with \verb`nc` to see if it works.
        \begin{itemize}
            \item \verb`nc vault1.momandpopsflags.ca 5555`
            \item Test out the protocol, realize that your human fingers are much too slow to get the partial flag.
        \end{itemize}
        \item Start to write a script in your programming language of choice that can do TCP socket programming.
        \begin{itemize}
            \item The easiest IMO is Python 3, using the \verb`socket` library.
            \item Don't worry about efficiency in this step, just make sure that it works (the protocol successfully terminates).
            \item If you can get one vault, great! Remember we have to get all 3 at the same time.
        \end{itemize}
        \item Find room to improve efficiency and reduce overhead.
        \begin{itemize}
            \item Realize that you don't have to waste time reading, writing, and reading, and writing before something useful happens. You can just \textbf{immediately} send BOTH messages since the first two responses from the server are neither useful nor have any dynamic information.
            \item Remember it's fine to hardcode stuff here, because we want to break this specific protocol, and not have a general solution!
        \end{itemize}
        \item Run against all the servers at the same time to get all the necessary information for the key.
        \begin{itemize}
            \item Assuming your script is fast enough, you can run it all from the same machine using shell trickery:
            \item \verb`python3 <script> vault1 &` \\
            \verb`    python3 <script> vault2 &` \\
            \verb`    python3 <script> vault3 & wait`
        \end{itemize}
        \item Decrypt the flag using the 3-part key, initial value, and ciphertext from the vaults, using any tool of your choice.
        \begin{itemize}
            \item \href{https://gchq.github.io/CyberChef}{CyberChef is pretty convenient}, but any tool works, as there is nothing special going on here besides the key being split up into 3 pieces.
        \end{itemize}
    \end{enumerate}

    \pagebreak


    \section{Full Solution \& Thought Process}\label{sec:full-solution-thought-process}

    \subsection{Specification}\label{subsec:specification}

    Every good protocol starts off with a specification. We want to read this thoroughly and make sure we understand it, because then scripting will be easier. Here we note that:

    \begin{itemize}
        \item There are 3 vaults at different addresses.
        \item The protocol does not seem to rely on any other application-level protocol (like HTTP, for example), so it's likely just raw TCP messaging.
        \item The protocol involves us sending strings back to one another.
        \item In the final step we have to send a challenge string back.
        \begin{itemize}
            \item This means we have to make sure we read the data the server sent us so we can send it back.
        \end{itemize}
        \item There is no mention of what port(s) this service runs on, so we will have to find this ourselves.
        \item We have to get responses from all servers within 2.4s or else the encryption rotates.
        \item We know what output to expect in both the successful and unsuccessful cases.
    \end{itemize}

    \subsection{Finding Ports}\label{subsec:finding-ports}

    Fresh off our exciting specification adventure, it seems that the first step is to find where the service we want is hosted. We know the IP addresses (\verb`vaultX.momandpopsflags.ca`), but not the port.

    Pick one of the three servers to scan, and use any port scanning tool of your choice. I chose to use \verb`nmap`, since it was installed on my system.

    \begin{lstlisting}[gobble=8,label={lst:nmap-command}]
        $ nmap -p 1-65535 -T4 -A -v vault1.momandpopsflags.ca
    \end{lstlisting}

    \pagebreak

    \noindent A quick explanation of the options:

    \begin{table*}[h!]
        \centering
        \label{tab:nmap-command}
        \begin{tabular}{|r|l|}
            \hline
            \textbf{Flag} & \textbf{Description}                            \\ \hline
            \verb`-p N-M` & scan ports from \verb`N` to \verb`M`            \\ \hline
            \verb`-T4`    & Aggressive timing template, speeds up execution \\ \hline
            \verb`-A`     & Aggressive scan, gives more information         \\ \hline
            \verb`-v`     & Verbose logging                                 \\ \hline
        \end{tabular}
    \end{table*}

    After running this (it might take a couple of minutes!) you should see an open TCP port at 5555. That looks pretty out-of-place, so that's probably the one we want. In the next section we'll verify this by using netcat (\verb`nc`) to poke the service and see if it's the right one.

    \subsection{Playing Around With netcat}\label{subsec:playing-around-with-netcat}

    Now that we've scanned all the ports, we want to test to see if we have the right one, and that we're talking to the right protocol. The likeliest port from the scan was 5555, so we try to connect using a tool like \verb`netcat`.

    \verb`netcat` is a very useful tool for testing arbitrary TCP/UDP connections. In the \hyperref[subsec:specification]{specification section}, we didn't find any evidence of an application-layer protocol and figured it was implemented using raw TCP messages. \verb`netcat` is perfect for this use-case.

    \bigskip

    Using the following command we can establish a connection and start sending messages:

    \begin{lstlisting}[gobble=8,label={lst:netcat-command}]
        $ nc vault1.momandpopsflags.ca 5555
    \end{lstlisting}

    After running this, you should immediately see a message from the server, ``\verb`oh hai!`''. This matches exactly with what we were expecting from the specification, so we know we're in the right place. The terminal appears to block, but that's because it's waiting for us to type something to send to the server.

    At this point it's a good idea to emulate the protocol to gain understanding about what exactly the server expects in terms of messages, etc. With TCP messages like this, you'll want to make sure you end your message with a newline so that it is sent. This particular point will be important later, but for the purposes of \verb`netcat`, it is sufficient just to hit return/enter.

    You may try to interact with all 3 vaults, but a cursory probe (just connecting, not going through the whole protocol) reveals that the services seem to be exactly the same, and are hosted on the same port on all 3 vaults (5555).

    \bigskip

    After manually playing around with the protocol (and likely getting the ``unsuccessful'' output at the end), it's now time to script, so we can get the outputs in the required amount of time.

    \subsection{Naive Script}\label{subsec:naive-script}

    \subsection{Improved Script}\label{subsec:improved-script}

    \subsection{Turn All The Keys!}\label{subsec:turn-all-the-keys}

    \subsection{Decrypting the Flag}\label{subsec:decrypting-the-flag}

    % (1/3): 0x9DEFE0C566FE0264664BE
    % IV: 0x4F5C25C4954F273472EC67AC494DADBD
    % Ciphertext: 0x917774AA5412A434FA9EC619585D07E8DF1A48952E15ACCFD702F7B47F2C8610685164ACF4C4CE919C4F436615CFD275

    % (2/3): 0x44D8BFCD0F625A8182A13
    % IV: 0x4F5C25C4954F273472EC67AC494DADBD
    % Ciphertext: 0x917774AA5412A434FA9EC619585D07E8DF1A48952E15ACCFD702F7B47F2C8610685164ACF4C4CE919C4F436615CFD275

    % (3/3): 0xFEE73E2A20D92242FA45B5
    % IV: 0x4F5C25C4954F273472EC67AC494DADBD
    % Ciphertext: 0x917774AA5412A434FA9EC619585D07E8DF1A48952E15ACCFD702F7B47F2C8610685164ACF4C4CE919C4F436615CFD275


    \section{Conclusion}\label{sec:conclusion}

    \pagebreak

    \appendix
    \section{Full Optimized Code}\label{sec:full-optimized-code}

    \begin{lstlisting}[gobble=8,label={lst:full-code},language=Python,basicstyle={\scriptsize\ttfamily}]
        import socket
        import sys

        def main(argv):
            # Argument checking
            if len(argv) < 1:
                print("You must provide the host as an argument!", file = sys.stderr)
                return

            # Host grabbed from CLI argument, port is the same for all 3 vaults
            host = argv[0]
            port = 5555
            buffer_size = 4096

            # Open a TCP socket and resolve the IPof the host we got from the CLI
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                ip = socket.gethostbyname(host)

                # Establish the connection (3-way handshake)
                s.connect((ip, port))

                # First attempt (introduces extra overhead)
                # s.sendall(b"INITIALIZE CONNECTION\n")
                # s.sendall(b"SEND FLAG\n")

                # Send both commands IMMEDIATELY, not caring whether there is data to read or not
                # bundle them both together to avoid extra overhead from sendall() being called twice
                s.sendall(b"INITIALIZE CONNECTION\nSEND FLAG\n")

                # get_challenge extracts the challenge string from the data the server sent us, and we just send it right back (part of protocol)
                s.sendall(get_challenge(buffer_size, s))

                # Read the response from the server after replying with the challenge string (hopefully we were quick enough!)
                res = get_response(buffer_size, s)
                print(res)

        def get_challenge(buffer_size, s) -> bytes:
            """Continues to read data from the socket, until we recognize the challenge string."""
            server_data = b''

            while True:
                # recv() blocks if there is no more data left to read, and the socket is still open
                server_data += s.recv(buffer_size)

                # First attempt (re library **might** not be as performant as string slicing)
                # match = re.findall(b'challenge string (.{7}\\n)', server_data)
                # if match:
                #     return match[0]

                # This is very hardcoded, but that's fine because we're just trying to break THIS protocol.
                # Sample bytestring: b'...with challenge string Z6D0N38\n' (remember, the `\n` is one character!)
                # They all have the same structure so if we check a slice of the output and get "str", we know that:
                # - We've read everything that the server has to send
                # - Our next command will be aligned properly
                if server_data[-15:-12] == b'str':
                    # Remember requests NEED to have a \n at the end to be considered "submitted", so we include that.
                    # i.e. 7 chars for the challenge, + 1 for the \n.
                    return server_data[-8:]

        def get_response(buffer_size, s):
            """Gets the final response from the server, assuming the rest of the protocol executed correctly."""
            server_data = b''

            try:
                while True:
                    # Keep reading data until a \n. Honestly this is a pretty flaky solution because there are 7 \n's in a successful final string, but the chances of a buffered read with a 4096 byte buffer ending on one of those intermediate ones is quite low, at least experimentally.
                    # If you run into problems, either remove it and ^C it yourself, OR use something like socket.select(). This worked for me, though.
                    server_data += s.recv(buffer_size)
                    if not server_data or server_data[-1] == ord(b'\n'):
                        break

                return server_data

            # In case something happens that causes us to block waiting for more data (can sometimes happen), a ^C will print what we captured already
            except KeyboardInterrupt:
                return server_data

        if __name__ == '__main__':
            # Removes program name from sysargs
            main(sys.argv[1:])
    \end{lstlisting}

\end{document}
